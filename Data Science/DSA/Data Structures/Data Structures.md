
Tags: #dsa 

------------------------------------------
1. [[Arrays]]: Arrays are a basic data structure that store elements of the same type in contiguous memory locations. They provide constant-time access to elements based on their indices. The uniqueness of arrays lies in their simplicity and ability to access elements directly, but they have a fixed size and are not efficient for dynamic resizing or frequent insertions/deletions.
    
2. Linked Lists: Linked lists are made up of nodes, each containing data and a reference to the next node. The uniqueness of linked lists lies in their dynamic nature, as they can grow and shrink as needed. They are efficient for insertions and deletions at any position, but accessing elements requires traversing the list from the beginning, resulting in slower random access.
    
3. Stacks: Stacks follow the Last-In-First-Out (LIFO) principle, where the last element added is the first one to be removed. They have a unique property of maintaining the order of elements and are often used for managing function calls, undo operations, or evaluating expressions.
    
4. Queues: Queues follow the First-In-First-Out (FIFO) principle, where the first element added is the first one to be removed. They maintain the order of elements and are suitable for scenarios like task scheduling, job processing, or handling incoming requests.
    
5. Trees: Trees are hierarchical structures composed of nodes connected by edges. They have a root node and can have child nodes, forming a branching structure. Trees are versatile and can be used to represent hierarchical relationships, search algorithms (e.g., binary search trees), or hierarchical data (e.g., file systems).
    
6. Graphs: Graphs consist of nodes (vertices) connected by edges. They represent relationships between entities and can be either directed or undirected. Graphs are used for modeling networks, social connections, recommendation systems, or solving complex problems like shortest path algorithms.
    
7. Hash Tables: Hash tables store key-value pairs and use a hash function to map keys to specific locations in an underlying array. They provide fast access and insertion times on average, making them efficient for lookups and indexing. Hash tables are commonly used for implementing dictionaries, caches, or symbol tables.
    
8. Heaps: Heaps are specialized tree-based structures that satisfy the heap property. They are often implemented as binary heaps and are efficient for maintaining a priority queue, where the highest (or lowest) priority element can be accessed quickly.
	
9. Hash Maps: Hash maps are similar to hash tables but often provide additional functionalities like resizing, dynamic allocation, and collision handling strategies. They are widely used for efficient key-value lookups, insertions, and deletions.
    
10. Tries: Tries, or prefix trees, are tree-like structures primarily used for efficient retrieval of strings or keys. They are often used in applications involving word search, autocomplete, and dictionary implementations.
    
11. Sets: Sets are data structures that store unique elements without any specific order. They are designed for efficient membership testing and provide operations like union, intersection, and difference. Sets are useful for solving problems that involve distinct elements or duplicate elimination.
    
12. Deques: A deque, short for double-ended queue, is a data structure that allows insertion and deletion of elements at both ends. It combines the features of stacks and queues and provides efficient operations for both FIFO and LIFO paradigms.
    
13. Priority Queues: Priority queues are data structures that store elements with associated priorities. Elements with higher priorities are accessed before elements with lower priorities. Priority queues are commonly used in scheduling, event handling, and graph algorithms like Dijkstra's algorithm.
    
14. Bloom Filters: Bloom filters are probabilistic data structures used for efficient membership testing. They provide fast lookups and can determine if an element is "probably" in a set, but they may have false positives. Bloom filters are often used in caching, spell-checking, and duplicate elimination scenarios.
    
15. Disjoint Sets: Disjoint sets, also known as union-find data structures, maintain a collection of disjoint sets and support operations like merging sets and finding the representative of a set. They are primarily used in graph algorithms, dynamic connectivity problems, and clustering applications.
    
16. Sparse Matrices: Sparse matrices are used to efficiently store and operate on matrices with a large number of zero elements. They employ different techniques, such as compressed sparse row (CSR) or compressed sparse column (CSC) formats, to save memory and optimize operations like matrix multiplication.
---------------------
#### links:
[[]]
[[]]